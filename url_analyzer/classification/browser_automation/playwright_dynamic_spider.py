"""

TODO: Switch to pushing buttons first rather than all interactable elements
TODO: Parallelize this among multiple tabs

"""
import re
import os
from typing import Dict, List, Optional, Set, Tuple
import uuid





from url_analyzer.classification.browser_automation.datamodel import BrowserUrlVisit, SignatureSequence
from url_analyzer.classification.browser_automation.playwright_page_manager import PlaywrightPageManager, PlaywrightPageManagerCloneContext
from url_analyzer.classification.browser_automation.datamodel import SignatureHandle
from url_analyzer.classification.browser_automation.run_calling_context import clone_playwright_and_click_signatures_in_sequence_and_find_new_signatures_with_context


from url_analyzer.classification.browser_automation.dynamic_spider_helpers import SignatureHandleKind, reload_url_until_signatures_appear_and_get_signatures
from url_analyzer.classification.utilities.utilities import chunked_gather
from url_analyzer.classification.utilities.single_visit_queue import sort_by_string
from url_analyzer.classification.utilities.logger import Logger


def filter_signature_sequence_list_with_regex(signature_sequence_list: List[SignatureSequence], signature_regex: str, verbose: bool) -> List[SignatureSequence]:
  new_signature_sequence_list = [
    signature_sequence for signature_sequence in signature_sequence_list
    if any([re.match(signature_regex, signature_handle.signature) is not None for signature_handle in signature_sequence.signature_sequence])]

  if verbose:
    print(f"Filtered signature_sequence_list with signature_regex: {signature_regex}. Before \n----\n{[[signature_handle.signature for signature_handle in signature_sequence.signature_sequence] for signature_sequence in signature_sequence_list]}\n----\n After \n----\n{[[signature_handle.signature for signature_handle in signature_sequence.signature_sequence] for signature_sequence in new_signature_sequence_list]}\n----\n")
  return new_signature_sequence_list



async def explore_page(
  playwright_page_manager: PlaywrightPageManager,
  url: str,
  parent_logger: Optional[Logger] = None,
  num_reloads: int = 6,
  include_all_clickable: bool = False,
  min_elements: int = 3,
  chunk_size: int = 10,
  signature_regex: Optional[str] = None,
  max_starting_signature_count: int = None,
  max_total_sequence_signature_count: int = None,
  verbose: bool = False
) -> Tuple[List[BrowserUrlVisit], Set[str]]:
  """

  This is a basic implementation of a javascript-focused spider for a single page. We open the page, identify all of the boxes and buttons on the page, and then go around clicking them and recording the browser_url_visit objects that this produces

  Args:
    playwright_page_manager: The playwright_page_manager to use
    url: The url to explore
    num_reloads: The number of times to reload the page before giving up
    include_all_clickable: If True, include all clickable elements, not just buttons
    min_elements: The minimum number of elements to find before we stop reloading the page
  Returns:
    A Dict[str, List[BrowserUrlVisit]] mapping from signature to a list of BrowserUrlVisit objects that were generated by clicking on that element
  """
  if parent_logger is None:
    # We use a default here because it is substantially more convenient to have a default dirname
    parent_logger = await Logger.construct_from_url_and_base_log_dir(url=url)

  browser_url_visit_list = []
  discovered_links_set = set()
  async with PlaywrightPageManagerCloneContext(playwright_page_manager) as cloned_playwright_page_manager:
    await cloned_playwright_page_manager.open_url(url)
    await cloned_playwright_page_manager.reload_and_click()

    interactable_signatures, text_input_field_signatures = await reload_url_until_signatures_appear_and_get_signatures(
      playwright_page_manager=cloned_playwright_page_manager,
      include_all_clickable=include_all_clickable,
      min_elements=min_elements, 
      num_reloads=num_reloads,
      logger=parent_logger
    )

    click_signature_handle_list = [SignatureHandle(kind=SignatureHandleKind.CLICK, signature=signature)
                                   for signature in sort_by_string(item_list=list(set(interactable_signatures))) ]
    submit_signature_handle_list = [SignatureHandle(kind=SignatureHandleKind.SUBMIT, signature=signature)
                                    for signature in sort_by_string(item_list=list(set(text_input_field_signatures))) ]

    if max_starting_signature_count is not None:
      click_signature_handle_list = click_signature_handle_list[:max_starting_signature_count]
      submit_signature_handle_list = submit_signature_handle_list[:max_starting_signature_count]


    # The first action in the sequence is always to fill all text fields. We only require that the target signature_handle is present
    signature_sequence_list = (
      [
        SignatureSequence(
          signature_sequence=[signature_handle],
          required_signatures={signature_handle.signature}
        )
        for signature_handle in (click_signature_handle_list + submit_signature_handle_list)
      ]
    )

    completed_signature_sequences = 0

    # Initialize the log directory
    while len(signature_sequence_list) > 0:
      if verbose:
        parent_logger.log(f"\n******\n[explore_page] Running another round of signature_sequence iteration over {signature_sequence_list}\n******\n")
  
      if signature_regex is not None:
        signature_sequence_list = filter_signature_sequence_list_with_regex(signature_sequence_list=signature_sequence_list, signature_regex=signature_regex, verbose=verbose)

      # We create a logger for each signature_sequence so that we can log the results of each signature_sequence
      logger_list = [
        await Logger.construct(
          key=str(i),
          dirname=os.path.join(parent_logger.dirname, str(uuid.uuid4())),
          initial_content=f"\n----\n{str(signature_sequence.signature_sequence)}\n----\n"
        )
        for i, signature_sequence in enumerate(signature_sequence_list)
      ]
      signature_sequence_action_result_list = await chunked_gather(
        awaitable_list=[
          clone_playwright_and_click_signatures_in_sequence_and_find_new_signatures_with_context(
            url=url,
            signature_sequence=signature_sequence,
            playwright_page_manager=cloned_playwright_page_manager,
            include_all_clickable=include_all_clickable,
            min_elements=min_elements,
            num_reloads=num_reloads,
            logger=logger
          )
          for signature_sequence, logger in zip(signature_sequence_list, logger_list)
        ],
        chunk_size=chunk_size
      )

      signature_sequence_list = []
      for signature_sequence_action_result in signature_sequence_action_result_list:
        if signature_sequence_action_result is not None:
          signature_sequence_list += signature_sequence_action_result.discovered_signature_sequence_list

          discovered_links_set.update(signature_sequence_action_result.discovered_links_set)

          parent_logger.log(f"[explore_page] Overall discovered_links_set: {discovered_links_set}")
          if signature_sequence_action_result.browser_url_visit is not None:
            browser_url_visit_list.append(signature_sequence_action_result.browser_url_visit)

      completed_signature_sequences += len(signature_sequence_action_result_list)
      if max_total_sequence_signature_count is not None and completed_signature_sequences >= max_total_sequence_signature_count:
        parent_logger.log(f"Stopping after {completed_signature_sequences} completed_signature_sequences")
        break
  return browser_url_visit_list, discovered_links_set
